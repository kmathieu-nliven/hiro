buildscript {
  repositories {
    mavenLocal()
    jcenter()
    mavenCentral()
    maven { url 'http://cbees-ltdev1-oradb1.transcendinsights.com:8081/nexus/content/groups/public' }
    maven { url "https://plugins.gradle.org/m2/" }
  }
  dependencies {
    classpath 'net.sf.opencsv:opencsv:2.3'
  }
}

import au.com.bytecode.opencsv.CSVReader
import groovy.text.GStringTemplateEngine
import groovy.transform.Canonical
import groovy.transform.EqualsAndHashCode
import groovy.transform.ToString
import groovy.transform.TupleConstructor

def inputDir = file('tables/x12_837p')
def outputDir = file('build/generatedSources/x12_837p')

class X12Util {

  static String inputDir, outputDir, basePackage

  static List<String[]> from(String filename) {
    new CSVReader(new File("$inputDir/${filename}.txt").newReader()).
        readAll()
  }

  static String toSymbol(String input, boolean downCase = false) {
    def output = input.replaceAll(/[^A-Za-z0-9_]/, '')
    def retval = output ==~ /^[0-9].*/ ? "M${output}" : output

    downCase ? (retval[0].toLowerCase() + retval[1..-1]) : retval
  }
}

X12Util.inputDir = inputDir.absolutePath
X12Util.outputDir = outputDir.absolutePath
X12Util.basePackage = 'com.cds.hiro.x12_837p'

logger.debug "InputDir : ${X12Util.inputDir}"
logger.debug "OutputDir: ${X12Util.outputDir}"

@Canonical
class TransactionSet {
  String transactionSetId, transactionSetName, functionalGroupId
  List<TransactionSetDetail> details = []
  List<? extends BlockElement> children = []
}

@TupleConstructor
@EqualsAndHashCode
@ToString(includeNames = true, excludes = 'theSegment,theLoop')
class TransactionSetDetail {
  String transactionSetId, area, sequence, segmentId, requirement, maxUse, loopLevel, loopRepeat, loopId
  Segment theSegment
  Loop theLoop
}

abstract class BlockElement {}

@Canonical(excludes = 'details')
class Segment extends BlockElement {
  String segmentId, segmentName
  List<SegmentDetail> details = []
}

@Canonical(excludes = 'children,parent')
class Loop extends BlockElement {
  String name, loopId
  int loopLevel
  Loop parent
  List<? extends BlockElement> children = []
}

@Canonical
class SegmentDetail {
  String segmentID, sequence, dataElementNumber, requirement, repeat
  Element element
  String toJavaType() {
    if (repeat != '1') {
      "List<${element.toJavaType()}>"
    } else {
      element.toJavaType()
    }
  }
}

interface Element {
  String getDataElementNumber()
  String getDataElementName()
  String toJavaType()
  String toFieldName()
  String toRow()
  boolean isEnum()
  boolean isComposite()
}

@Canonical
class SimpleElement implements Element {
  String dataElementNumber, dataElementName, dataElementType, minimumLength, maximumLength
  List<EnumType> enumerations = []

  @Override
  String toJavaType() {
    switch (dataElementType) {
      case 'AN': return 'String'
      case 'ID': return enumerations.size()>0 ? X12Util.toSymbol(dataElementName) : 'String'
      case 'N0': return 'Integer'
      case 'R': return 'Double'
      case 'DT': return 'java.time.LocalDate'
      case 'TM': return 'java.time.LocalTime'
      default:
        println "Unhandled type ${dataElementType}"
        return 'Object'
    }
  }

  @Override
  String toFieldName() {
    return X12Util.toSymbol(dataElementName, true)
  }

  @Override
  String toRow() {
    """\
      |"${dataElementNumber}","${dataElementName}"
      |   * "${dataElementNumber}","${dataElementType}","${minimumLength}","${maximumLength}" """.stripMargin()
  }

  @Override
  boolean isEnum() {
    return enumerations.size() > 0
  }

  @Override
  boolean isComposite() {
    return false
  }
}

@Canonical
class CompositeElement implements Element {
  String dataElementNumber, dataElementName
  List<ElementDetail> details = []

  @Override
  String toJavaType() {
    X12Util.toSymbol(dataElementName)
  }

  @Override
  String toFieldName() {
    return X12Util.toSymbol(dataElementName, true)
  }

  @Override
  String toRow() {
    /"${dataElementNumber}","${dataElementName}"/
  }

  @Override
  boolean isEnum() {
    return false
  }

  @Override
  boolean isComposite() {
    return true
  }
}

@Canonical
class ElementDetail {
  String sequence, dataElementNumber, requirement
  Element element
}

@Canonical
class EnumType {
  String code, name
  String getRepresentation() {
    X12Util.toSymbol(name)
  }
}

File dir(String name) {
  def basePackage = new File(name)
  basePackage.mkdirs()
  return basePackage
}
File dir(File parent, String name) {
  def basePackage = new File(parent, name)
  basePackage.mkdirs()
  return basePackage
}

task codegen << {


  List<TransactionSet> transactionSets = []
  List<TransactionSetDetail> transactionSetDetails = []
  List<Segment> segments = []
  List<SegmentDetail> segmentDetails = []
  List<? extends Element> elements = []

  X12Util.from('elehead').
      each { line -> elements << new SimpleElement(*line) }
  X12Util.from('eledetl').
      each { line ->
        if (line.find { it.trim() }) {
          def element = elements.find { it.dataElementNumber == line[0] } as SimpleElement
          element.dataElementType = line[1]
          element.minimumLength = line[2]
          element.maximumLength = line[3]
        }
      }


  X12Util.from('comhead').
      each { line -> elements << new CompositeElement(*line) }
  X12Util.from('comdetl').
      each { line ->
        if (line.find { it.trim() }) {
          def element = elements.find { it.dataElementNumber == line[0] } as CompositeElement
          def detail = new ElementDetail(*line[1..3])
          detail.element = elements.find { it.dataElementNumber == detail.dataElementNumber }
          element.details << detail
        }
      }


  X12Util.from('seghead').
      each { line -> segments << new Segment(*line) }
  X12Util.from('segdetl').
      each { line ->
        if (line.find { it.trim() }) {
          def detail = new SegmentDetail(*line)
          detail.element = elements.find { it.dataElementNumber == detail.dataElementNumber }
          segmentDetails << detail
          segments.find { it.segmentId == line[0] }.details << detail
        }
      }


  List<Loop> loops = []
  Loop root, current
  X12Util.from('sethead').
      each { transactionSets << new TransactionSet(*it) }
  X12Util.from('setdetl').
      each { line ->
        def detail = new TransactionSetDetail(*line)
        transactionSetDetails << detail
        transactionSets.find { it.transactionSetId == line[0] }.details << detail
        ///TODO: finish the tree
        int loopLevel = Integer.parseInt(detail.loopLevel)
        if (!root) {
          root = new Loop(loopId: 'BASE', loopLevel: 0)
          current = root
        } else {
          if (current.loopLevel + 1 == loopLevel) { //we're going to next level
            Loop newChild = new Loop(
                loopId: detail.loopId, loopLevel: loopLevel, parent: current,
                name: X12Util.toSymbol("L${detail.loopId}")
            )
            detail.theLoop = newChild
            loops << newChild
            current.children << newChild
            current = newChild
          } else { //we're on the same level or need to go back to same level
            if (current.loopLevel > loopLevel) {
              (current.loopLevel - loopLevel).times { current = current.parent }
            }
            if (detail.loopId) {
              def parent = current.parent
              current = new Loop(
                  loopId: detail.loopId, loopLevel: loopLevel, parent: parent,
                  name: X12Util.toSymbol("L${detail.loopId}")
              )
              detail.theLoop = current
              loops << current
              parent.children << current
            } else {
              detail.theSegment = segments.find {it.segmentId == detail.segmentId}
            }
          }
        }
        //Given the current node, add segment to its children
        def segment = segments.find { it.segmentId == detail.segmentId }
        assert segment
        current.children << segment
      }

  transactionSets.find {it}.children = root.children

  new File(X12Util.outputDir).deleteDir()
  new File(X12Util.outputDir).mkdirs()

  def basePackage = dir("${X12Util.outputDir}/${X12Util.basePackage.replace('.', '/')}")
  def segsDir = dir(basePackage, 'segments')
  def transactionSetDir = dir(basePackage, 'transactionsets')
  def comDir = dir(basePackage, 'composites')
  def eDir = dir(basePackage, 'enums')
  def loopsDir = dir(basePackage, 'loops')

  def ffData = new File(X12Util.inputDir, 'freeform.txt').text.split(/\n\*/)
  ffData.
      findAll {it.startsWith 'ELECOD'}.
      each {
        def (header, dataLine, text) = it.split(/\n/, 3).toList()
        def data = dataLine.split(',')
        def enumType = new EnumType(data[2], text.replaceAll(/[\r\n]/, ' ').trim())
        def element = elements.find {it.dataElementNumber == data[0]} as SimpleElement
        if (element) {
          element.enumerations << enumType
        }
      }


  elements.
      findAll { it instanceof SimpleElement && it.dataElementType == 'ID' && it.enumerations.size() > 0 }.
      each {
        def map = it.properties
        map['packageName'] = 'com.cds.hiro.x12_837p.enums'

        map.className = X12Util.toSymbol(it.dataElementName)
        new GStringTemplateEngine().
            createTemplate(file('templates/enum.gtpl')).
            make(map).
            writeTo(
                new File(eDir, "${map.className}.java").newWriter()
            ).
            close()
      }

  elements.
      findAll { it instanceof CompositeElement }.
      each {
        def map = it.properties
        map['packageName'] = 'com.cds.hiro.x12_837p.composites'

        map.className = X12Util.toSymbol(it.dataElementName)
        new GStringTemplateEngine().
            createTemplate(file('templates/composite.gtpl')).
            make(map).
            writeTo(
                new File(comDir, "${map.className}.groovy").newWriter()
            ).
            close()
      }

  segments.
      each {
        def map = it.properties
        map['packageName'] = 'com.cds.hiro.x12_837p.segments'

        map.className = X12Util.toSymbol(it.segmentId)
        new GStringTemplateEngine().
            createTemplate(file('templates/segment.gtpl')).
            make(map).
            writeTo(
                new File(segsDir, "${map.className}.groovy").newWriter()
            ).
            close()
      }

  loops.
      each {
        def map = it.properties
        map['packageName'] = 'com.cds.hiro.x12_837p.loops'

        map.className = X12Util.toSymbol(it.name)
        new GStringTemplateEngine().
            createTemplate(file('templates/loop.gtpl')).
            make(map).
            writeTo(
                new File(loopsDir, "${map.className}.groovy").newWriter()
            ).
            close()
      }

  transactionSets.
      each {
        def map = it.properties
        map['packageName'] = 'com.cds.hiro.x12_837p.transactionsets'

        map.className = X12Util.toSymbol(it.transactionSetId)
        new GStringTemplateEngine().
            createTemplate(file('templates/transactionset.gtpl')).
            make(map).
            writeTo(
                new File(transactionSetDir, "${map.className}.groovy").newWriter()
            ).
            close()
      }

}

